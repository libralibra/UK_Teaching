'''
    Pathfinding workshop using Dijkstra's Algorithm (Uniform Cost Search)

    Dr Daniel Zhang @ Falmouth University
    2023 - 2024
'''
import sys
from gui_lib import *
from queue import PriorityQueue


class DIJKSTRA(Canvas):
    def __init__(self, title, width, height, bgcolour='white', animate=True, nb_size=4, euclidean_dist=False) -> None:
        ''' nb_size controls how may neighbours to search: 4 or 8 '''
        super().__init__(title, width, height, bgcolour)
        self.animate = animate
        # neighbourhood size
        self.nb_size = nb_size
        # neighbourhood size
        self.nb_size = nb_size
        # use Euclidean distance rather than Manhattan distance
        self.euc_dist = euclidean_dist
        self.showHelp()

    def neighbours(self, c: Cell):
        ''' get the neighbours of the given cell '''
        n = []
        # north
        if c.row > 0 and self.grids[c.row-1][c.col] != CellType.BLOCK:
            n.append(Cell(c.row-1, c.col, c))
        # north east
        if self.nb_size == 8:
            if c.row > 0 and c.col < self.x_grid_num-1 and self.grids[c.row-1][c.col+1] != CellType.BLOCK:
                n.append(Cell(c.row-1, c.col+1, c))
        # east
        if c.col < self.x_grid_num-1 and self.grids[c.row][c.col+1] != CellType.BLOCK:
            n.append(Cell(c.row, c.col+1, c))
        # south east
        if self.nb_size == 8:
            if c.row < self.y_grid_num-1 and c.col < self.x_grid_num-1 and self.grids[c.row+1][c.col+1] != CellType.BLOCK:
                n.append(Cell(c.row+1, c.col+1, c))
        # south
        if c.row < self.y_grid_num-1 and self.grids[c.row+1][c.col] != CellType.BLOCK:
            n.append(Cell(c.row+1, c.col, c))
        # south west
        if self.nb_size == 8:
            if c.row < self.y_grid_num-1 and c.col > 0 and self.grids[c.row+1][c.col-1] != CellType.BLOCK:
                n.append(Cell(c.row+1, c.col-1, c))
        # west
        if c.col > 0 and self.grids[c.row][c.col-1] != CellType.BLOCK:
            n.append(Cell(c.row, c.col-1, c))
        # north west
        if self.nb_size == 8:
            if c.row > 0 and c.col > 0 and self.grids[c.row-1][c.col-1] != CellType.BLOCK:
                n.append(Cell(c.row-1, c.col-1, c))
        return n

    def search(self):
        ''' BFS search from start to the end, record the path list '''
        # ----------------------------------------------
        # YOU CODE HERE, CREATE OTHER HELPER FUNCTIONS AS YOU NEED
        # ----------------------------------------------


if __name__ == '__main__':
    euclidean_dist = False
    if len(sys.argv) > 1 and int(sys.argv[1]) == 1:
        euclidean_dist = True
    animate = True
    neighbours = 4
    dijkstra = DIJKSTRA(
        "COMP712/Pathfinding BFS Demo - Falmouth University 2023-2024", 800, 600, 'white', animate, neighbours, euclidean_dist)
    dijkstra.setGridNum(40, 30)
    dijkstra.mainloop()
